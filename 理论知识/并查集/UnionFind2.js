/**
 * 第二版的并查集（使用数组实现）
 *
 * 举例：
 * parent    0 1 2 3 4 5 6 7 8 9
 * ------------------------------
 * value     0 1 2 3 4 5 6 7 8 9
 *
 * 1. 初始时，节点全部指向自身，如图所示：
 *     ╭─╮   ╭─╮   ╭─╮   ╭─╮   ╭─╮   ╭─╮   ╭─╮   ╭─╮   ╭─╮   ╭─╮
 *    ╭↓─┴╮ ╭↓─┴╮ ╭↓─┴╮ ╭↓─┴╮ ╭↓─┴╮ ╭↓─┴╮ ╭↓─┴╮ ╭↓─┴╮ ╭↓─┴╮ ╭↓─┴╮
 *    │ 0 │ │ 1 │ │ 2 │ │ 3 │ │ 4 │ │ 5 │ │ 6 │ │ 7 │ │ 8 │ │ 9 │
 *    ╰───╯ ╰───╯ ╰───╯ ╰───╯ ╰───╯ ╰───╯ ╰───╯ ╰───╯ ╰───╯ ╰───╯
 *
 * 2. 执行 `union(3, 4)` 后，将“节点 4”指向“节点 3”，如图所示：
 *     ╭─╮   ╭─╮   ╭─╮   ╭─╮   ╭─╮   ╭─╮   ╭─╮   ╭─╮   ╭─╮
 *    ╭↓─┴╮ ╭↓─┴╮ ╭↓─┴╮ ╭↓─┴╮ ╭↓─┴╮ ╭↓─┴╮ ╭↓─┴╮ ╭↓─┴╮ ╭↓─┴╮
 *    │ 0 │ │ 1 │ │ 2 │ │ 3 │ │ 5 │ │ 6 │ │ 7 │ │ 8 │ │ 9 │
 *    ╰───╯ ╰───╯ ╰───╯ ╰───╯ ╰───╯ ╰───╯ ╰───╯ ╰───╯ ╰───╯
 *                        ↑
 *                      ╭─┴─╮
 *                      │ 4 │
 *                      ╰───╯
 *    数据如下：
 *    parent    0 1 2 3  4  5 6 7 8 9
 *    -------------------------------
 *    value     0 1 2 3 (3) 5 6 7 8 9
 *
 * 3. 执行 `union(4, 9)` 后，将“节点 9”指向“节点 4 的根节点，即节点 3”，如图所示：
 *     ╭─╮   ╭─╮   ╭─╮   ╭─╮   ╭─╮   ╭─╮   ╭─╮   ╭─╮
 *    ╭↓─┴╮ ╭↓─┴╮ ╭↓─┴╮ ╭↓─┴╮ ╭↓─┴╮ ╭↓─┴╮ ╭↓─┴╮ ╭↓─┴╮
 *    │ 0 │ │ 1 │ │ 2 │ │ 3 │ │ 5 │ │ 6 │ │ 7 │ │ 8 │
 *    ╰───╯ ╰───╯ ╰───╯ ╰───╯ ╰───╯ ╰───╯ ╰───╯ ╰───╯
 *                        ↑  ↖
 *                      ╭─┴─╮ ╭───╮
 *                      │ 4 │ │ 9 │
 *                      ╰───╯ ╰───╯
 *    数据如下：
 *    parent    0 1 2 3  4  5 6 7 8  9
 *    ---------------------------------
 *    value     0 1 2 3 (3) 5 6 7 8 (3)
 *
 *    之所以将“节点 9 指向节点 4 的根节点”，是为了防止退化成链表
 *
 * 存在问题
 * 1. 没有压缩路径（优化方法：将根节点下的所有节点，都平铺指向根节点）
 *    如下图，根节点为 3，某些分支为链表，查询起来性能不好：
 *                ╭─╮
 *               ╭↓─┴╮
 *               │ 3 │
 *               ╰───╯
 *              ↗  ↑  ↖
 *         ╭───╮ ╭─┴─╮ ╭───╮
 *         │ 6 │ │ 4 │ │ 9 │
 *         ╰───╯ ╰───╯ ╰───╯
 *           ↑     ↑
 *         ╭─┴─╮ ╭─┴─╮
 *         │ 7 │ │ 5 │
 *         ╰───╯ ╰───╯
 *
 * 2. 可能退化成链表（优化方法：使用 size 或 rank 来优化集合的合并）
 *    如下图，较大的树合并到较小的树上时，就会退化成链表：
 *   （步骤一）           （步骤二）            （依次类推。。。）
 *     ╭─╮   ╭─╮                 ╭─╮
 *    ╭↓─┴╮ ╭↓─┴╮               ╭↓─┴╮
 *    │ 3 │ │ 5 │               │ 5 │
 *    ╰───╯ ╰───╯               ╰───╯
 *      ↑                      ↗
 *    ╭─┴─╮               ╭───╮
 *    │ 4 │               │ 3 │
 *    ╰───╯               ╰───╯
 *                          ↑
 *                        ╭─┴─╮
 *                        │ 4 │
 *                        ╰───╯
 */

class UnionFind2 {
  parent = [];

  constructor(size) {
    // 初始化 parent 数组，指向本身，表示初始以自己为根节点
    for (let i = 0; i < size; i++) {
      this.parent[i] = i;
    }
  }

  toString = () => {
    return this.parent.join(', ');
  };

  getSize = () => {
    return this.parent.length;
  };

  find = (p) => {
    if (p < 0 || p >= this.parent.length) {
      throw new Error('ERR [UnionFind3]: find 方法的参数不合法');
    }

    // 一直向上找到树的根节点，直到找到自身
    while (p !== this.parent[p]) {
      p = this.parent[p];
    }

    return p;
  };

  isConnected = (p1, p2) => {
    return this.find(p1) === this.find(p2);
  };

  union = (p1, p2) => {
    const root1 = this.find(p1);
    const root2 = this.find(p2);

    if (root1 === root2) return;

    this.parent[p2] = root1;
  };
}

module.exports = UnionFind2;
