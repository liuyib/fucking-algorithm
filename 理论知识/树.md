- [树](#树)
  - [二叉树](#二叉树)
    - [二叉树分类](#二叉树分类)
    - [二叉树的表示](#二叉树的表示)
    - [二叉树遍历](#二叉树遍历)
      - [前中后序遍历的递归解法](#前中后序遍历的递归解法)
      - [前中后序遍历的非递归解法](#前中后序遍历的非递归解法)
    - [二叉树构建](#二叉树构建)
  - [二叉搜索树](#二叉搜索树)
  - [堆](#堆)
    - [推荐题目](#推荐题目)
  - [相关专题](#相关专题)
  - [题目推荐](#题目推荐)

# 树

## 二叉树

### 二叉树分类

- 完全二叉树
- 满二叉树
- 二分搜索树
- [平衡二叉树](https://github.com/azl397985856/leetcode/blob/master/thinkings/balanced-tree.md)
- 红黑树
- 。。。

### 二叉树的表示

- 链表存储
- 数组存储。非常适合**完全二叉树**

### 二叉树遍历

1. 前序遍历
2. 中序遍历
3. 后序遍历
4. 层序遍历（BFS）

#### 前中后序遍历的递归解法

略

#### 前中后序遍历的非递归解法

- 统一思路 1：使用标记元素

  代码示例，前序遍历（中序、后序类似）：

  ```js
  var preOrder = function (root) {
    const FLAG = '#';
    const nodes = [root];
    const res = [];

    while (nodes.length) {
      const top = nodes.pop();

      if (!top) continue;
      if (top !== FLAG) {
        nodes.push(top.right);
        nodes.push(top.left);

        // 中序、后序遍历把这两行代码换位置就行
        nodes.push(top);
        nodes.push(FLAG);
      } else {
        res.push(nodes.pop());
      }
    }

    return res;
  };
  ```

- 统一思路 2：双色标记法

  垃圾回收算法中，有一种算法叫三色标记法。 即：

  - 用白色表示尚未访问
  - 灰色表示尚未完全访问子节点
  - 黑色表示子节点全部访问

  那么我们可以模仿其思想，使用双色标记法来统一实现三种遍历。其核心思想如下：

  - 白色表示新节点
  - 灰色表示已访问的节点
  - 遇到白色节点，将其标记为灰色，然后“自身、左节点、右节点”按需依次入栈
  - 遇到节点灰色，将其值输出

  代码示例，前序遍历（中序、后序类似）：

  ```js
  var preOrder = function (root) {
    const WHITE = 0;
    const GRAY = 1;
    const nodes = [[WHITE, root]];
    const res = [];

    while (nodes.length) {
      const [color, top] = nodes.pop();

      if (!top) continue;
      if (color === WHITE) {
        nodes.push([WHITE, top.right]);
        nodes.push([WHITE, top.left]);
        nodes.push([GRAY, top]);
      } else {
        res.push(top.val);
      }
    }

    return res;
  };
  ```

### 二叉树构建

**中序序列**和**前、后、层序列**任意组合唯一确定一颗二叉树（前提是遍历是**基于引用**的或者二叉树的**值都不相同**）。**前、后、层序列**都是提供根结点的信息，**中序序列**用来区分左右子树。

> 单前/中/后序遍历是无法确定一棵树。

实际上构造一棵树的本质是：

1. 确定根节点
2. 确定其左子树
3. 确定其右子树

比如拿到前序遍历和中序遍历，在前序遍历我们可以能确定树根 root，拿到 root 可以将中序遍历切割中左右子树。这样就可以确定并构造一棵树，整个过程我们可以用递归完成。详情见 [构建二叉树专题](https://github.com/azl397985856/leetcode/blob/master/selected/construct-binary-tree.md)

## 二叉搜索树

二叉搜索树是二叉树的一种，具有以下性质

1. 左子树的所有节点值小于根的节点值（注意不含等号）
2. 右子树的所有节点值大于根的节点值（注意不含等号）
3. 中序遍历结果是一个有序列表

例题：[1008. 前序遍历构造二叉搜索树](https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal/description/)。

思路：根据先序遍历构建对应的二叉搜索树，由于二叉树的中序遍历是一个有序列表，我们有以下思路：

1. 对先序遍历结果排序，**排序结果是中序遍历的结果**
2. 根据先序遍历和中序遍历构造一棵树，原问题就又转换为了上面我们讲的《二叉树构建》

## 堆

在这里讲堆是因为堆可以被看作近似的完全二叉树。堆通常以数组形式的存储，而非上述的链式存储。

表示堆的数组 `A` 中，如果 `A[1]` 为根节点，那么给定任意节点 `i`，其父子节点分别为

- 父亲节点：`Math.floor(i / 2)`
- 左子节点：`2 * i`
- 右子节点: `2 * i + 1`

如果 `A[parent(i)] >= A[i]`，则称该堆为最大堆，如果 `A[parent(i)] <= A[i]`，称该堆为最小堆。

堆这个数据结构有很多应用，比如堆排序，TopK 问题，共享计算机系统的作业调度（优先队列）等。

### 推荐题目

- 汉诺塔问题
- fibonacci 数列
- 二叉树的前中后序遍历
- 归并排序
- 求阶乘
- 递归求和

## 相关专题

- 二叉树的最大路径和
- 给出所有路径和等于给定值的路径
- 最近公共祖先
- 各种遍历。前中后，层次，拉链式等
- [专题篇 - 搜索](./topic-search.md)
- [二叉树的遍历](https://github.com/azl397985856/leetcode/blob/master/thinkings/binary-tree-traversal.md)
- [前缀树专题](https://github.com/azl397985856/leetcode/blob/master/thinkings/trie.md)

## 题目推荐

- [589. N 叉树的前序遍历](https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/)（熟悉 N 叉树）
- [662. 二叉树最大宽度](https://leetcode-cn.com/problems/maximum-width-of-binary-tree/) (请分别使用 BFS 和 DFS 解决)
- [834. 树中距离之和](https://leetcode-cn.com/problems/sum-of-distances-in-tree/description/)（谷歌面试题）
- [967. 连续差相同的数字](https://leetcode-cn.com/problems/numbers-with-same-consecutive-differences/description/) (隐形树的遍历)
- [1145. 二叉树着色游戏](https://leetcode-cn.com/problems/binary-tree-coloring-game/)（树上进行决策）
