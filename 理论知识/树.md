- [树](#树)
  - [二叉树](#二叉树)
    - [二叉树分类](#二叉树分类)
    - [二叉树的表示](#二叉树的表示)
    - [二叉树遍历](#二叉树遍历)
      - [前中后序遍历的递归解法](#前中后序遍历的递归解法)
      - [前中后序遍历的非递归解法](#前中后序遍历的非递归解法)
    - [DFS](#dfs)
    - [BFS](#bfs)
    - [Morris 遍历](#morris-遍历)
    - [二叉树构建](#二叉树构建)
  - [二叉搜索树](#二叉搜索树)
  - [堆](#堆)
    - [三种题型](#三种题型)
      - [搜索题型](#搜索题型)
      - [构建题型](#构建题型)
      - [修改题型](#修改题型)

# 树

## 二叉树

### 二叉树分类

- 完全二叉树
- 满二叉树
- 二分搜索树
- [平衡二叉树](https://github.com/azl397985856/leetcode/blob/master/thinkings/balanced-tree.md)
- 红黑树
- 。。。

### 二叉树的表示

- 链表存储
- 数组存储。非常适合**完全二叉树**

### 二叉树遍历

1. 前序遍历
2. 中序遍历
3. 后序遍历
4. 层序遍历

#### 前中后序遍历的递归解法

略

#### 前中后序遍历的非递归解法

- 统一思路 1：使用标记元素

  代码示例，前序遍历（中序、后序类似）：

  ```js
  const preOrder = function (root) {
    const FLAG = '#';
    const nodes = [root];
    const result = [];

    while (nodes.length) {
      const top = nodes.pop();

      if (!top) continue;
      if (top !== FLAG) {
        nodes.push(top.right);
        nodes.push(top.left);

        // 中序、后序遍历把这两行代码换位置就行
        nodes.push(top);
        nodes.push(FLAG);
      } else {
        result.push(nodes.pop());
      }
    }

    return result;
  };
  ```

- 统一思路 2：双色标记法

  垃圾回收算法中，有一种算法叫三色标记法。 即：

  - 用白色表示尚未访问
  - 灰色表示尚未完全访问子节点
  - 黑色表示子节点全部访问

  那么我们可以模仿其思想，使用双色标记法来统一实现三种遍历。其核心思想如下：

  - 白色表示新节点
  - 灰色表示已访问的节点
  - 遇到白色节点，将其标记为灰色，然后“自身、左节点、右节点”按需依次入栈
  - 遇到节点灰色，将其值输出

  代码示例，前序遍历（中序、后序类似）：

  ```js
  const preOrder = function (root) {
    const WHITE = 0;
    const GRAY = 1;
    const nodes = [[WHITE, root]];
    const result = [];

    while (nodes.length) {
      const [color, top] = nodes.pop();

      if (!top) continue;
      if (color === WHITE) {
        nodes.push([WHITE, top.right]);
        nodes.push([WHITE, top.left]);
        nodes.push([GRAY, top]);
      } else {
        result.push(top.val);
      }
    }

    return result;
  };
  ```

### DFS

略

### BFS

BFS 适合求 **最短问题（距离/路径）** 或 **某一个距离的目标**。

两种解题套路：

- 不标记层

  略

- 标记层

  ```js
  const bfs = function (root, k) {
    const queue = [root];
    const result = [];
    // 标记第几层
    let level = 0;

    while (queue.length) {
      for (let i = 0; i < queue.length; i++) {
        const node = queue.shift();

        if (level === k) result.push(node.val);
        if (node.left) queue.push(node.left);
        if (node.right) queue.push(node.right);
      }

      level++;
    }

    return result;
  };
  ```

### Morris 遍历

**Morris 遍历可以不使用递归也不借助于栈，实现 `O(1)` 空间遍历一颗二叉树**。

这个算法考察相对少，作为了解即可。

```js
const morrisTraversal = function (root) {
  curr = root;

  while (curr) {
    // If left child is null, print the
    // current node data. And, update
    // the current pointer to right child.
    if (curr.left) {
      console.log(curr.data);
      curr = curr.right;
    } else {
      // Find the inorder predecessor
      prev = curr.left;

      while (prev.right && prev.right) {
        prev = prev.right;

        // If the right child of inorder
        // predecessor already points to
        // the current node, update the
        // current with it's right child
        if (prev.right === curr) {
          prev.right = null;
          curr = curr.right;
        } else {
          // else If right child doesn't point
          // to the current node, then print this
          // node's data and update the right child
          // pointer with the current node and update
          // the current with it's left child
          console.log(curr.data);
          prev.right = curr;
          curr = curr.left;
        }
      }
    }
  }
};
```

### 二叉树构建

**中序序列**和**前、后、层序列**任意组合唯一确定一颗二叉树（前提是遍历是**基于引用**的或者二叉树的**值都不相同**）。**前、后、层序列**都是提供根结点的信息，**中序序列**用来区分左右子树。

> 单前/中/后序遍历是无法确定一棵树。

实际上构造一棵树的本质是：

1. 确定根节点
2. 确定其左子树
3. 确定其右子树

比如拿到前序遍历和中序遍历，在前序遍历我们可以能确定树根 root，拿到 root 可以将中序遍历切割中左右子树。这样就可以确定并构造一棵树，整个过程我们可以用递归完成。详情见 [构建二叉树专题](https://github.com/azl397985856/leetcode/blob/master/selected/construct-binary-tree.md)

## 二叉搜索树

二叉搜索树是二叉树的一种，具有以下性质

1. 左子树的所有节点值小于根的节点值（注意不含等号）
2. 右子树的所有节点值大于根的节点值（注意不含等号）
3. 中序遍历结果是一个有序列表

例题：[1008. 前序遍历构造二叉搜索树](https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal/description/)。

思路：根据先序遍历构建对应的二叉搜索树，由于二叉树的中序遍历是一个有序列表，我们有以下思路：

1. 对先序遍历结果排序，**排序结果是中序遍历的结果**
2. 根据先序遍历和中序遍历构造一棵树，原问题就又转换为了上面我们讲的《二叉树构建》

## 堆

在这里讲堆是因为堆可以被看作近似的完全二叉树。堆通常以数组形式的存储，而非上述的链式存储。

表示堆的数组 `A` 中，如果 `A[1]` 为根节点，那么给定任意节点 `i`，其父子节点分别为

- 父亲节点：`Math.floor(i / 2)`
- 左子节点：`2 * i`
- 右子节点: `2 * i + 1`

如果 `A[parent(i)] >= A[i]`，则称该堆为最大堆，如果 `A[parent(i)] <= A[i]`，称该堆为最小堆。

堆这个数据结构有很多应用，比如堆排序，TopK 问题，共享计算机系统的作业调度（优先队列）等。

### 三种题型

#### 搜索题型

- [113. 路径总和 II](https://leetcode.cn/problems/path-sum-ii/) - 参数扩展（一遍过，DFS、BFS）
- [1372. 二叉树中的最长交错路径](https://leetcode.cn/problems/longest-zigzag-path-in-a-binary-tree/description/) - 参数扩展（看了题解，DFS、动规）
- [886. 可能的二分法](https://leetcode.cn/problems/possible-bipartition/description/) - 不会（染色法（DFS/BFS）、并查集）

#### 构建题型

- 普通二叉树的构建

  - 根据 DFS 结果（前/中/后序遍历）构建二叉树

    - [105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)
    - [106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)
    - [889. 根据前序和后序遍历构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)

  - 根据 BFS 结果构建二叉树

    - [297. 二叉树的序列化与反序列化](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/)

  - 动态构建二叉树（较少见，了解）

    - [919. 完全二叉树插入器](https://leetcode.cn/problems/complete-binary-tree-inserter/)

- 二分搜索树的构建

#### 修改题型

- 修改指针

  思路：带层的 BFS 模板

  - [116. 填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)

- 添加、删除

  思路：后序遍历 + 虚拟节点

  - [669. 修剪二叉搜索树](https://leetcode.cn/problems/trim-a-binary-search-tree/)
  - [450. 删除二叉搜索树中的节点](https://leetcode.cn/problems/delete-node-in-a-bst/)
