- [哈希表](#哈希表)
  - [介绍](#介绍)
  - [哈希函数](#哈希函数)
  - [哈希冲突的处理](#哈希冲突的处理)
    - [链地址法](#链地址法)
    - [开放地址法](#开放地址法)
  - [常用操作的时间复杂度](#常用操作的时间复杂度)
  - [常见的题类型](#常见的题类型)
  - [模板（伪代码）](#模板伪代码)
  - [题目推荐](#题目推荐)
    - [多人运动](#多人运动)
    - [思路](#思路)

# 哈希表

## 介绍

- 底层实现：把键通过哈希函数转换成索引，根据索引把对应的值存到数组中。

- 实现方式：

  - **数组 + 链表**
  - **数组 + 红黑树**

  > JDK1.8 的 `HashMap` 就同时使用了这两种方式：当哈希冲突小于一定阈值时，采用**数组 + 链表**；达到阈值后，转换为**数组 + 红黑树**。

- 哈希函数：根据键来算出 HashCode（通常是一个数字），根据 HashCode 来随机访问数组。

  理论上两个不同的键是可以算出同样的 HashCode 的，这个就叫做哈希冲突。比如 JDK1.8 的哈希函数就是先通过键算出 HashCode（32 位的 int 值），然后让 HashCode 的高 16 位和低 16 位进行异或操作。之所以这么做是因为这样做的哈希冲突的概率会小，那什么是哈希冲突呢？

- 哈希冲突：哈希函数不是万能的，可能出现不同的键算出来的哈希值相同。比如哈希函数是 `x % 3`，这样 `键=2` 和 `键=5` 算出的哈希值都为 2。这是要怎么办呢？一般我们有两种方法来处理，**链地址法**和**开放地址法**。

- 哈希表的性能：构造一个冲突小，稳定性高的哈希函数是很重要的，我们在刷题的时候大部分时间都不会去考虑这个问题，但是实际工程中有时不可避免需要我们自己构造哈希函数，这时就要根据实际情况进行分析测试啦。

## 哈希函数

理想情况下 **“键”通过哈希函数算出的“索引”分布越均匀越好**，实际上是很难达到这个情况的。

为了尽可能达到这个理想情况，对于一些特殊领域，甚至有专门的领域内的哈希函数。

哈希函数对于键的处理，情况如下（这里只讨论简单且一般情况）：

- 键是**整数**时

  - 小范围的正整数，直接使用
  - 小范围的负整数，偏移后使用。例：`-100 ~ 100` -> `0 ~ 200`
  - 大整数，通常做法“取模”。相比与模一个合数，**模一个素数的哈希冲突更低**，例如：

    ```text
    10 % 4 -> 2     10 % 7 -> 3
    20 % 4 -> 0     20 % 7 -> 6
    30 % 4 -> 2     30 % 7 -> 2
    40 % 4 -> 0     40 % 7 -> 5
    ```

  > 模的素数该怎么选，可以参考：http://planetmath.org/goodhashtableprimes

- 键是**浮点数**时

  转成整数来处理。

- 键是**字符串**时

  转成整数来处理。举例如下：

  ```text
  // 先回顾下二进制的计算：
  166 = 1 * 10^2 + 6 * 10^1 + 6 * 10^0

  // 参考这个思路，给字符串定一个进制，然后做计算（这里以英文举例）：
  code = c * 26^3 + o * 26^2 + d * 26^1 + e * 26^0

  // 如果更通用一点，让进制可配置（其中 B 是进制，可以由用户指定）：
  code = c * B^3 + o * B^2 + d * B^1 + e * B^0

  // 最终，计算过程如下（B：进制，M：素数）：
  hash(code) = (c * B^3 + o * B^2 + d * B^1 + e * B^0) % M

  // 实际计算过程中，这个公式可能产生很大的数（溢出风险），因此可以优化成以下格式：
  hash(code) = ((((c * B) + o) * B + d) * B + e) % M

  // 由于还存在数字溢出风险，进一步优化（每次乘以 B 之前取模）：
  hash(code) = ((((c % M * B) + o) % M * B + d) % M * B + e) % M
  ```

  上述最后一个式子，用代码表示如下：

  ```java
  int hash = 0;

  for(int i = 0; i < s.length(); i++) {
    hash = (hash * B + s.charAt(i)) % M;
  }
  ```

- 键是**复合类型**时

  转成整数来处理。例如，键是一个时间类：`Date: year, month, day`，我们依然可以复用上面的式子：

  ```java
  hash(code) = ((((date.year % M * B) + date.month) % M * B + date.day) % M * B) % M
  ```

以上的情况，“将键转成了整数”来处理不是唯一的方法。总之，哈希函数设计时，应遵循以下原则：

- 一致性：如果 a == b，则 hash(a) == hash(b)
- 高效性：计算简单高效
- 均匀性：哈希值分布均匀

## 哈希冲突的处理

### 链地址法

### 开放地址法

## 常用操作的时间复杂度

- 插入：O(1)
- 删除：O(1)
- 查找：O(1)

是的，常用的操作在非极其特殊情况下，平均的时间复杂度都为**O(1)**

## 常见的题类型

- **统计 xx 出现次数/频率/** （见下方多人运动）

该种题比较直观，若已知数据范围较小且比较连续，可以考虑用数组来实现。

题目推荐：

- [811.子域名访问计数](https://leetcode-cn.com/problems/subdomain-visit-count/description/)

- **需要查找/增加/删除操作为 O(1)时间复杂度** （一些设计题）

见到这种要求的题可以考虑一下是否需要哈希表来做，比如 LRU，LFU 之类的题，题目中要求了时间复杂度，就是用哈希表+双向链表解决的。

- **题目类型为图数据结构相关** （比如并查集）

这样可能需要构建有向图/无向图，这时可以用哈希表来表示图并进行后续操作。

- **需要存储之前的状态以减少计算开销**（比如经典的两数和）

相信大家做过 dp 的一些题目就知道，记忆化搜索，该方法就利用哈希表来存储历史状态，这样可以大大减少重复计算。

- **等等，大家多做类似的题目，相信可以总结出一套自己的思路。**

## 模板（伪代码）

1. 判断目标值是否出现过（例题如：两数之和、是否存在重复元素、合法数独等等）

```python
for num in nums:
    if num(该处为目标值target) in hashtable:
	return true
return false
```

2. 统计频率

数据比较离散

```python
for num in nums:
    if num in hashtable:
	hashtable[num] += 1
    else
	hashtable[num] = 1
# 后续操作
-------------------
```

数据范围较小且连续则可以用数组代替

```java
// 假设数据范围是0-n且n较小
int[] hashtable = new int[n + 1];

for num in nums:
    hashtable[num] += 1;

// 后续操作
------------------
```

## 题目推荐

### 多人运动

已知小猪每晚都要约好几个女生到酒店房间。每个女生 i 与小猪约好的时间由 `[si , ei]` 表示，其中 si 表示女生进入房间的时间， ei 表示女生离开房间的时间。由于小猪心胸开阔，思想开明，不同女生可以同时存在于小猪的房间。请计算出小猪最多同时在做几人的「多人运动」。

例子：

Input： `[[0, 30], [5, 10], [15, 20]]`

OutPut：最多同时有两个女生的「三人运动」

### 思路

这个题 解法不止一种，但是我们这里因为在讲哈希表，统计频率。下面我只写一下大致思路的伪代码，具体细节大家不妨可以尝试自己实现一下。

```java
// 上面刚刚说了关于频率统计的方法，这里读完题，是不是就立刻想到了：
// 用hash表来统计每个时刻房间内的人数并维护一个最大值就是我们所求的结果啦

res = -1

for everyGirl in girls:
    for curTime in [everyGirl.start, everyGirl.end]:
	// 套上面板子
	if curTime in hashtable:
	    hashtable[curTime] += 1
	else
	    hashtable[curTime] = 1

	// 维护最大值
	res = max(res, hashtable[curTime])

----------------------------
```

线下验证通过可以贴到这里哦，[【每日一题】- 2020-04-27 - 多人运动](https://github.com/azl397985856/leetcode/issues/347)

这里还有各种解题方法，大家都可以学习下思路并试着自己做一做！

类似推荐

- [面试题 01.04. 回文排列](https://leetcode-cn.com/problems/palindrome-permutation-lcci/)
- [500. 键盘行](https://leetcode-cn.com/problems/keyboard-row/description/)
- [36. 有效的数独](https://leetcode-cn.com/problems/valid-sudoku/description/)
- [37. 解数独](https://leetcode-cn.com/problems/sudoku-solver/description/) 与 36 类似，还需要点回溯的思想
